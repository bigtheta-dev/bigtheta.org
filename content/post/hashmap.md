---
title: "Hashmap"
date: 2018-09-16T14:53:45+03:00
draft: false
tags: ["hashmap", "collection"]
categories: ["java technology"]
---

**HashMap** - реализация ассоциативного массива для Java

<!--more-->

---

## Интефейс Map

Интерфейс Map в Java реализует концепцию ассоциативного массива. Ассоциативный массив расширение обычного массива. Так обычный массив сопоставляет множество целочисленный значений множеству каких либо объектов, а ассоциативный массив сопоставлят множество объектов к множеству каких либо других объектов. Ключи ассоциативного массива аналогичны индексам массива, а значения - значениям массива. Ключаме ассоциативного массива могут быть объекты удовлетворяющие некоторым условиям.

Интерфейс Map базовый интерфейс для всех ассоциативных массивов Java. Основные операции:

* ``size()`` - размер массива
* ``get()`` - взятие элемента по ключу 
* ``put()`` - добавление элемента  
* ``remove()`` - удаление элемента по ключу
* ``keySet()`` - полючения всех ключей
* ``values()`` - получение всех значений

## Контракты equals и hashcode

Для того что работа с HashMap в Java была корректна необходимо соблюсти ряд контрактов при реализации hashCode и equals для новых классов. Для классов из стандартной библиотеки эти контракты выполняются. Эти контракты указаны в JavaDoc класса Object.

### equals()

Используется для сравнения двух объектов. Возвращает true если объекты равны, false в противном случае. Метод должен обеспечивать следующие свойства:

* рефлексивность: x eq x для любых x
* симметричность: если x eq y то y eq x
* транзитивность: если x eq y, y eq z то x eq z 
* консистентность:  для одних и тех же объектов результат будет тот же.
* при сравнение с null возвращает false

### hashCode()

возвращает целочисленное значение для объекта

* консистентен в рамках одного исполнения - для одних и тех же объектов результат будет тот же в пределах одного исполения.
* если объекты равны по equals то они должны иметь равные хешкоды
* если объекты имеют равные хешкоды то они не обязательно должны быть равны по equals. Это условие обуславливает наличие коллизий. 

### ключи

* ключи для мапы должны быть неизменяемы. Если ключи изменяемы то алгоритм не работает корректно

## Способы реализации мапы

Алгорим работы мапы можно поделить на два подалгоритма:

1. Алгоритм вычисления хеша 
2. Алгоритм разрешения коллизий

Для алгоритма вычисления хеша используются устоявшиеся методы. 

Алгоритм разрешение коллизий является неотъемлемой части реализации ассоциативного массива т.к. обычно размер множества значение существенно превышает размер множества ключей и наличия колизий никак не избежать. Для разрешения коллизий могут использоваться разнообразные подходы. Так наиболее часто употребимыми среди них являются метод открытой адресации(open adressing) и метод цепочек(separate chaining). В свою очередь у каждого из этих подходов есть свои реализации.

### Алгоритм вычисления хеша

Здесь в основном много берется из математики. Этот алгоритм должен равномерно распределять множество ключей на множество значений. При самостоятельном реализации это алгоритма можно столкнуться с нектороыми проблемами что приведет к тому что написанная хеш функция будет выдавать множество коллизий. Поэтому при создании своей хеш функции стоит обратить вниманимание на несколько вещей:

1. для всех встроенных типов в языке уже написаны оптимальные алгоритмы для вычесления хеша, не стоит их писать самому
2. для пользовательских типов устойчивой от коллизий хеш функции можно добиться следующим алгоритмом:
 - берут некоторое простое число (стандартно 31, удобно т.к. умножение на 31 реализуются сдвигом на 5 бит и вычитанием самого числа)
 - итерируются по всем полям объекта, которые должны учитываться при вычислении хеша умножая на простое число и складывае с результатом промежуточных вычислений. 

### Разрешение коллизий. Метод открытой адресации

Самая простая из реализаций это метод линейного пробирования (linear probing).

Используется массив размерность которого превосходит количество элеменотов. Для того чтобы поместить элемент в ассоциативный массив вычисляется хешкод элемента и номер ячейки вычисляется из хешкода. 

Для добавления элемента ищется ячейка через хешкода. В том случае если эта ячейка занята берется следующая(до того момента пока не будет найдена свободная). Здесь влияние оказываета наличие коллизий. Возрастание количетва коллизий приводи к образованию кластеров (последовательно идущих друг за другом элементов). При этом для вставки элемента необходимо проитероваться по всем элементам такого кластера.

Для выборки элемента также берется хешкод элемена и вычисляется номер ячейки и дальше начинается последовательный перебор ячеек кластера. Перебор заканчивается если находится ключ равный искомому и возвращается найденное значение, либо если перебор закончился пустой ячейкой тогда искомого значения нет в ассоциативном массиве. Здесь как и в добавлении роль играет рамер кластера.

При удаление также происходит линейный перебор. Ищется элемент в пределах текущего кластера. После того как искомый элемент найден оставшиеся элементы кластера перехешируются и перемещаются на новые позиции. 

При реализации ассоциативного массива методом открытой адрессации важно чтобы размер массива превосходил количество элементов в мапе. Оптимальным является соотношение 1:2.

### Разрешение коллизий. Метод цепочек

Используется массив для хранения некоторых подструктур. В качестве подструктур могут использоваться связанные списки либо деревья. Самый простой пример когда цепочка представляе собой список. При вставке елемента номер цепочки вычисляется при помощи хешкода. Элемент добавляется в цепочку. Размер массива выбирается таким образом чтобы цепочки были в среднем из одного элемента.

Поиск элемента происходит посредством вычисления номера цепочки через хешкод ключа. Далее присходит последовательный перебор элементов цепочки. При переборе внутри цепочки сравнивается значение ключа. Поиск заканчивается удачно если найден равный ключ. Если достигнут конец цепочки то искомого элемента нет. 

В том случае если количество коллизий минимально то длина цепочки в среднем не больше одного и выборка происходит за константное время. Если количество коллизий велико то могут составляться достаточно большие цепочки и время доступа будет вырождаться вплоть до линейного.

Для удаление произовдится поиск элемента. Если элемент найден то он удаляется из списка.

## Реализация в Java

В Java HashMap реализована на основе метода цепочек.

* **Initial capacity**. Указывается начальные размер мапы

``` java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

* **Load factor**. Указывается при каком наполнение будет происходить пересчет размера

``` java
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```
* **Увеличение размера**. В случае если количество элементов в мапе становится большим чем LoadFactor x InitialCapacity то происходит перехеширование и мапа увеличивается. В JDK8 мапа увеличивается в 2 раза:

``` java
newCap = oldCap << 1
``` 
### Изменения в Java 8

В Java 8 добавлен алгоритм при котором длинные цепочки из списка пересчитываются в дерево позволяя добиться логарифмическое время доступа в худшем случае. Использования деревьев хорошо работает в том случае если цепочки получаются довольно большого размера. Поэтом введены следуюищие пороги:

``` java
static final int TREEIFY_THRESHOLD = 8;
```

``` java
static final int UNTREEIFY_THRESHOLD = 6;
```

``` java
static final int MIN_TREEIFY_CAPACITY = 64;
```

Цепочка пересчитывается в дерево в том случае если в нем `TREEIFY_THRESHOLD` и более элементов. В том случае если число элементов менне `UNTREEIFY_THRESHOLD` то дерево снова разворачивается в цепочку. Так же есть зависимость от размера мапы. в случае если capacity мапы меньше `MIN_TREEIFY_CAPACITY`, то цепочки также не пересчитываются в деревья.

Для того чтобы этот алгоритм работал оптимально необходимо чтобы ключи мапы реализовывали Comparable. В том случае если не реализуют тогда построение дерева также происходит, но для сравнения берется значение System.identyHashCode ключа. В таком случае алгоритм работае существенно медленне.

## Другие реализации интерфейса

### LinkedHashMap

HashMap для которой учитывается порядок добавление элементов. Используются для реализации LRU кеша.

### TreeMap

Ассоциативный массив на основе двоичных деревьев поиска.

### SkipListMap

Многопоточная реализация ассоциативного массива на основе скиплистов.

### ConcurentHashMap

Многопоточная реализация на основе хешмапы и локов на чтение-запись для отдельных цепочек.

### WeahHashMap

Особенность является то что значениея удаляются из мапы если они не используются нигде кроме как в этой мапе (удаляется последняя ссылка на объект)

### EnumMap

Реализация мапы ключами у которой выступает enum





