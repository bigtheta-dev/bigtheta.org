---
title: "Maven"
date: 2018-04-22T15:34:24+03:00
draft: false
tags: ["maven", "dependency management", "m2"]
categories: ["java technology"]
---

**Maven** - система сборки проектов для Java. На данный момент это стандарт в языке.

<!--more-->

По большей мере есть одно альтернатива - Gradle. Он чуть меньше распространен, но достаточно быстро набирает популярность.



![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/Maven_logo.svg/220px-Maven_logo.svg.png)


**Maven** решает проблемы автоматизации сборки и уравления зависимостями как и другие инструменты этого класса, но имеет некоторые характерные черты:

* *Maven следует соглашениям по конфигурации*. Он знает какая у проекта должна быть структура,откуда брать файлы ресурсов и куда складывать созданные jar-файлы. И пользователям maven приходится соблюдать эти соглашения.
* *Maven декларативен*. Описание проекта в pom.xml представляется в декларативном виде. Декларативное представление отличается от императивного тем что оно отвечает плавным образом на вопрос что надо сделать чтобы собрать проект (императивное отвечает на вопрос как это сделать). 
* *Maven вводит понятие жизненного цикла*. Жизненный цикл представляет собой группу последовательных фаз, которые maven исполняет по порядку для достижения определенной цели. К фазам жизненного цикла могут быть прикреплены дополнительные действия при помощи плагинов.
 
---
## Структура POM


Описание (*Project Object Model*) представляется в виде xml файла **pom.xml**, который помещается в корень проекта. [Структура *pom.xml*](https://maven.apache.org/pom.html) выглядит следующим образом:

``` xml
<project ... >
	<modelVersion>4.0.0</modelVersion>

	<!-- Основная информация -->
	<groupId>...</groupId>
	<artifactId>...</artifactId>
	<version>...</version>
	<packaging>...</packaging>
	<dependencies>...</dependencies>
	<parent>...</parent>
	<dependencyManagement>...</dependencyManagement>
	<modules>...</modules>
	<properties>...</properties>

	<!-- Настройки сборки -->
	<build>...</build>
	<reporting>...</reporting>

	<!-- Метаданные проекта -->
	<name>...</name>
	<description>...</description>
	<url>...</url>
	<inceptionYear>...</inceptionYear>
	<licenses>...</licenses>
	<organization>...</organization>
	<developers>...</developers>
	<contributors>...</contributors>

	<!-- Окружение -->
	<issueManagement>...</issueManagement>
	<ciManagement>...</ciManagement>
	<mailingLists>...</mailingLists>
	<scm>...</scm>
	<prerequisites>...</prerequisites>
	<repositories>...</repositories>
	<pluginRepositories>...</pluginRepositories>
	<distributionManagement>...</distributionManagement>
	<profiles>...</profiles>
</project>
```

### Основная информация
Здесь указываются настройки описывающие проект с точки зрения зависимостей.

1. Определяет координаты, полностью описывающие артефакт в который будет собираться проект/модуль:
    * **groupId** - обычно описывает организацию, в которой создан проект. Часто использутеся обратная запись доменного имени сайта организации
    * **artifactId** - обычно название проекта
    * **version** - версия
    * **packaging** - вид поставки (jar, war, ear, zip, dir и т.п.)
2. Также здесь имеются секции для управления зависимостями 
    * **dependency** - для указания зависимостей, использующихся в данном модуле.
    * **dependencyManagement** - для указания зависимостей, которые будут использованы в дочерних модулях (концепция Reactor)
3. Указываются ссылки на родительский и дочернии модули: *modules*, *parent*

### Настройки сборки
Здесь указываются дополнительные действия запускающиеся в процессе сборки

1. В **build** указываются расширяющие возможности сборки, в том числе *plugins*, *pluginManagement*
2. В **reporting** можно подсоединить плагины для генерации отчетов

### Метаданные проекта
Здесь указывается информация описывающая артифакт. В том числе имя артефакта, описание, авторы, лицензии и т.п. Эта информация может быть очень полезна при публикации артифакта в удаленный репозиторий

### Окружение
Здесь располагается информация о разнообразном окружении:

1. Профили - можно указать различные профили сборки, чтобы гибко управлять процессом сборки на различных окружениях (dev, ci, prod)
2. Репозитории и репозитории плагинов - можно указать дополнительные репозиторий из которых Maven будет брать зависимости и плагины
3. Списки рассылки
4. Ссылки на систему контроля версий, систему непрерывной интеграции, баг трекер и т.п.
Включает всю информацию про окружение: списки рассылки, репозитории ...

---
## POM inheritance
### Super POM
Все проекты собирающиеся с использованием Maven наследуются от общего родителя, который называется Super POM. В этом POM указаны ряд настроек, предустановленных для все maven проектов. В нем указаны следующие настройки:

* в качестве репозитория для зависимостей и плагинов указан [Maven Central](http://repo1.maven.org/maven2)
* в build секции указывается структура дерева директория по умолчанию
* в pluginManagement версии по умолчанию для часто использующихся плагинов

Для того чтобы собрать свой проект достаточно только указать минимальное описание, включающее в себя **groupId**, **artifactId**, **version**. Остальные данные будут взяты из **Super POM**. Так может выглядеть минимальный **POM**
``` xml
<project>
	<modelVersion>4.0.0</modelVersion>
	<groupId>org.bigtheta</groupId>
	<artifactId>mvn</artifactId>
	<version>1</version>
</project>
```
### Effective POM
Для того чтобы работать с проектом **Maven** объединяет **Super POM** и **POM** конкретного проекта. В результате этого получается **Effective POM** с которым даллее происходит вся работа.

---
## Архетип
Для простоты создания новых проектов maven вводит такое поняти как архетип. Архетип - это заранне заготовленный шаблон проекта. При создании проекта из архетипа полность восстанавливается дерево директорий, устанавливаются необходимые зависимости. 

Процесс создания проекта из архетипа выглядит следующем образом:
``` bash
mvn archetype:generate -DgroupId=org.bigtheta -DartifactId=mvn
``` 
либо можно создать проект в интерактивном режиме
``` bash
mvn archetype:generate
```
Если указать только artefactId и groupId своего проекта, а остальные значения опставить пустыми (т.е. по умолчанию), то maven сгенерируют проект из архетипа **maven-archetype-quickstart** и мы получим такую структуру проекта
``` bash
.
└── example
    ├── pom.xml
    └── src
        ├── main
        │   └── java
        │       └── org
        │           └── bigtheta
        │               └── mvn
        │                   └── App.java
        └── test
            └── java
                └── org
                    └── bigtheta
                        └── mvn
                            └── AppTest.java
```

Имеются тысячи уже готовых архетипов для разных фреймворков, и типов проектов. В том случае если у вас часто создаются проект с одинаковым сценарием, библиотеками и т.п. можно создать свой архетип.

---
## Жизненный цикл  

Maven использует понятие [жизненного цикла](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html). Жизненный цикл представляет собой последовательность фаз. Каждая фаза выполняет некоторое определенное действие. Выполнение происходит последовательно, т.е. сначала по порядку исполняются все предшествующие фазы, а затем исполняется указанная фаза. 

В maven имеются три преднастроенных жизненных цикла: **clean**, **default**, **site**

1. **clean** lifecycle - используется для очистки проекта. Имеет следующие фазы:
   * **pre-clean** - выполняет необходимые операции предшествующие очистке
   * **clean** - удаление всех файлов созданных в процессе сборки
   * **post-clean** - executes processes required to finalize project cleaning

2. **default** lifecycle - используется для процесса компиляции, тестирования и деплоймента. Он включает в себя более 20 фаз. Вот наиболее важные:

   * **validate** - проверяет что проект соответствует соглашениям и имеется вся информация необходимая для сборки
   * **compile** - компиляция исходного кода
   * **test** - запуск юнит тестов с использование тестового фреймворка.
   * **package** - упаковка компилированного кода в указанный формат
   * **integration-test** - загрузка сборки в тестовое окружение, проведения интеграционного тестирования
   * **verify** - проверка что созданная сборка удовлетворяет всем указанным критериям
   * **install** - загрузка сборки в локальный репозиторий
   * **deploy** - загрузка сборки в удаленный репозиторий

3. **site** lifecycle - включает в себя создание и загрузку на сервер проектной документации:
   * **pre-site** - исполняет действия предшествующие созданию документации
   * **site** - создание проектной документации
   * **post-site** - испольняет действия необходимые после создания документации
   * **site-deploy** - загрузка документации на сервер

### Исполнение цели
Для запуска определенный цели используется синтаксис:
``` bash
mvn clean
```
Также можно указывать несколько целей:
``` bash
mvn clean package
```
---


### Плагины

Для расширения функциональности Maven испольется инструментарий плагинов. На данный момент можно найти плагин почти для любой кастомного поведения. Если нужен очень специфичный функционал то можно написать свой. Добавить плагин в pom можно используя инструкция *plugins* в секции *build*. Выглядит следующим образом:

``` xml
<plugins>
	<plugin>
		<groupId>...</groupId>
		<artifactId>...</artifactId>
		<version>...</version>
		<configuration>
			...
		</configuration>
		<executions>
			<execution>
				<id>...</id>
				<goals>
					<goal>...</goal>
				</goals>
			</execution>
		</executions>
	</plugin>
</plugins>
```

Конфигурация плагина задается в разделе *configuration*, а привязка исполнения плагина к цели в разделе *execution*.

Существуют множество разнообразных плагинов. Часто одну и ту же функциональность можно достичь используя разные плагины. Вот те без которых не обходится почти ни один проект:

1. [**maven-compiler-plugin**](https://maven.apache.org/plugins/maven-compiler-plugin/) - включен в поставку Maven. Используется для компиляции исходного кода. Указывает какую версию JDK использовать.

``` xml
<build>
    <sourceDirectory>src</sourceDirectory>
    <plugins>
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.1</version>
            <configuration>
                <source>1.7</source>
                <target>1.7</target>
            </configuration>
        </plugin>
    </plugins>
</build>
```

2. [**maven-surefire-plugin**](http://maven.apache.org/surefire/maven-surefire-plugin/) - используется для прогона тестов. При его помощи можно кастомизирвать поведение этой фазы.

3. [**maven-assembly-plugin**](http://maven.apache.org/plugins/maven-assembly-plugin/) - позволяет собирать различные виды артефактов jar, war, zip и многое другое.

4. [**maven-jetty-plugin**](https://www.eclipse.org/jetty/documentation/9.4.x/jetty-maven-plugin.html) - возможность использоват контейнер сервлетов Jetty без сборки war и деплоя. Очень удобно при разработке.


5. [**maven-dependency-plugin**](https://maven.apache.org/plugins/maven-dependency-plugin/) - анализ зависимостей проекта. Даёт возможность обнаружить конфликты транзитивных зависимостей и другое.

6. [**maven-shade-plugin**](https://maven.apache.org/plugins/maven-shade-plugin/) - сборка артефакта в jar и скрытие (shade) зависимостей. Полезен в случае транзитивных зависимостей.

7. [**maven-jar-plugin**](https://maven.apache.org/plugins/maven-jar-plugin/) - сборка исходного кода проекта в jar.

8. [**maven-war-plugin**](https://maven.apache.org/plugins/maven-war-plugin/) - сборка проекта в war.

9. [**maven-deploy-plugin**](http://maven.apache.org/plugins/maven-deploy-plugin/) - выгрузка собранного артефакта в удаленные репозиторий.

10. [**maven-resource-plugin**](https://maven.apache.org/plugins/maven-resources-plugin/) - копирование ресурсов при сборке.

11. [**maven-enforcer-plugin**](https://maven.apache.org/enforcer/maven-enforcer-plugin/) - возможность установки правил при которых сборка будет падать.

## Управление зависимостями

Для [управления зависимостями](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html) используется секция *dependency*. По умолчанию Maven работает с Maven Central репозиторием (он указана в Super POM, от которого наследуются все проекты). Добавить свои репозитории можно в секцию *repositories* 
Для ссылки на зависимость необходимо указать четыре атрибута. Зависимость выглядит следующим образом:

``` xml
<dependencies>
	<dependency>
		<groupId>...</groupId>
		<artifactId>...</artifactId>
		<version>...</version>
		<scope>...</scope>
	</dependency>
</dependencies>
```
Maven разрешает зависимости на первых шагах жизненного цикла по умолчанию. Делается это при помощи [maven-dependency-plugin](https://maven.apache.org/plugins/maven-dependency-plugin/index.html), поддержка которого вшита в Super POM. Первые это стандартное описание артефакта. Помимо них есть еще атрибут *dependency scope*

### Dependency scope
Dependency scope используется для ограничения использования зависимости и более гибкого управления ей.

1. **compile** - область видимости по умолчанию. Зависимость помещается в classpath проекта и может быть использована в зависимых проектах
2. **provided** - указывает что зависимость будет добавлена JDK или J2EE контейнером. Считается не очень хорошим тоном указывать так зависимость т.к. нельзя точно гарантировать версию зависимости на prod и это такое рассогласование с dev может привести к прохим последствиям 
3. **runtime** - зависимость не нужна для компиляции, а должна подкладываться только в runtime
4. **test** - зависимости необходимы только для процесса компиляции и выполнения тестов
5. **system** - аналогична *provided*
6. **import** - поддерживаются только зависимости с типом pom из *dependencyManagement* родительского pom. Указывает что зависимость будет замещена версией из *dependencyManagement*


### Транзитивные зависимости

Часто бывает что необходимые для проекта также зависят от других пакетов. Зависимости второго и более глубоких уровней называются транзитивными. 

В Maven принято явно указывать версию зависимости. Могут быть такие ситуации когда в транзитивных зависимостях оказывается один и тот же пакет. В том случае если версия пакета одна то проблем быть не должно. Но если версии разные то возникает *конфликт транзитивных зависимостей*. Он возникает из-за того что в Java полное имя класса (пакет + имя класса) должно быть уникальным. В том случае если в classpath попадают классы с одинаковым полным именем из них остаться должен только один. Стоим отметить что такой конфликт возможен также в том случае если добавляются разные пакеты, но по какой-то причине полное имя класса совпадает (один из разработчиков пакета нарушил соглашение об именование).

Maven встречаясь с конфликтом тразитивных зависимостей успешно его разрешает и продолжает сборку проекта. В том случае если необходимо чтобы в таком случае сборка падала применяется [maven envorcer plugin с правилом dependency convergence](http://maven.apache.org/enforcer/enforcer-rules/dependencyConvergence.html) 

При конфликте транзитивных зависимостей Maven использует стратегию *nearest*, которая означает что будет взята та зависимость, которая находится ближе к корню проекта. Такое поведение может не всегда устраивать, так как чаще всего при решение таких зависимостей удовлетворяет выбор пакета с более поздней версией. Для указанию чтобы была взята другая зависимость есть несколько путей:

* Прописать нужную зависимость явно в pom, который находится ближе к корню проекта. Таким образом эта зависимость "задавит" другую.
* Можно найти от какой зависимости приходит ненужная конфликтная зависимость и прописать ее в exculusions
``` xml
<dependency>
        <groupId>sample.ProjectA</groupId>
        <artifactId>Project-A</artifactId>
        <version>1.0</version>
        <scope>compile</scope>
        <exclusions>
            <exclusion>  <!-- declare the exclusion here -->
                <groupId>sample.ProjectB</groupId>
                <artifactId>Project-B</artifactId>
            </exclusion>
        </exclusions> 
</dependency>
```

---

## Многомодульный проект
В больших проектах принято разделять код отвечающий за разную область на модули. Разделение на модули, помимо уменьшения связности кода, позволяет использовать артефакты модулей одного проекта в других проектах. 

В Maven каждый отдельный модуль описывается своим pom файлом. Чтобы создать многомодульный проект необходимо объявить родительский pom который будет являться корнем, а также дочерние pom. В родительском pom указываются дочерние модули в секции **modules**, а также указывается **packaging**:**pom**:

``` xml
...
<groupId>...</groupId>
<artifactId>parent</artifactId>
<packaging>pom</packaging>
<version>1.0</version>
<modules>
	<module>child-ar</module>
	<module>child-b</module>
</modules>
...
```

В дочерних модулях необходимо сослаться на родителя и указать **artifactId** самого модуля. Если между модулями существует зависимости то они указываются как обычно в секции **dependencies**. Вот структура дочернего pom:

``` xml
...
<parent>
	<groupId>...</groupId>
	<artifactId>parent</artifactId>
	<version>1.0</version>
</parent>
<artifactId>child-a</artifactId>
<packaging>jar</packaging>
...
```
Как к родительскому так и к дочерним модулям можно подключать плагины, кастомизировать сборку, собирать наборы модулей в разные артефакты. 

### Reactor
Для сборки многомодульного проекта используется концепция [Reactor](https://maven.apache.org/guides/mini/guide-multiple-modules.html). Reactor для сборки проекта выполняет ряд дейтсвий:

1. Обнаружение всех модулей.
2. Поиск правильного порядка сборки модулей.
3. Сборка всех модулей в необходимом порядке.

Помимо этого он добавляет возможность ссылаться на зависимости (**dependencyManagement**), и плагины (**pluginManagement**) из дочерних модулей на родительский. Работа с зависимостями реализуется следующим образом:

* в родительском pom указывается зависимости в секции **dependencyManagement**, указывается нужная версия зависимости. 

* в дочерних pom указывается секция **dependencies**, но версия не указывается. Она будет взята из родительского pom.

Наличие зависимости в **dependencyManagement** не достаточно чтобы Maven принялся загружать ее. Зависимость приходит только там где она помещена в секцию **dependency**  Это позволяет добиться того что во всем проекте используется одно версия какой-либо библиотеки и сущетсвует единая точка в которой ее можно изменить.

### BOM
В Maven сущетсвуют поддержка концепции build of material. Это дальнейшее развитие идеи **dependencyManagement**. При использовании BOM вы не заботитесь о версиях пакетов своего проекта, а отдаете эту проблему третьим людям. Согласно этой концепции составляются списки версий разнообразных пакетов работа, взаимодействие которых проверено и гарантируется их совместная работоспособность. Разработчики фреймворков публикуют такие списки у себя обеспечивая централизованную схему управления зависимостями. Для того чтобы указать что необходимо использовать все зависимости для SPRING определенной можно указать в родительском pom:

``` xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>4.3.8.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

Помимо использования сторонних BOM также можно самому написать BOM для использования в своих проектах.

---
## CI/CD с Maven

Системы автоматизированной сборки неотъемлемая часть процесса непрерывной интерграции. Они используются как и отдельными разработчиками так и на билд серверах. Далее пойдет речь о том как использовать Maven в CI/CD. Приведенный пример один из возможных и отнюдь не единственный вариант построения процесса разработки.

### Репозитории

Maven ищет зависимости в репозиториях. Для того чтобы указать Maven дополнительные репозитории необходимо указать их в файле **Settings.xml**, который обычно помещается в папку **.m2**. Этот файл хранит настройки, которые должны быть разделены между всеми проектами. В этом файле также храниться информация о нахождении локального репозитория и информация для аутентификации. 

Концептуально есть три типа репозиториев:

* *Локальный репозиторий* - этот тип репозитория представляет собой локальное хранилище, куда помещаются все зависимости скачанные из сети. Обычно располагается в **.m2/repository**. Представляет своего рода кэш. Позволяет собирать проект при отсутсвии доступа к сети, в том случае если зависимости уже когда-то использовались. Зависимости автоматически добавляются в локальный репозиторий, а удалить их можно только вручную. Стоит сказать что зависимости в локальном репозитории могут быть разные и вследсвие этого поведение при сборке проекта у одного разработчика может отличаться от поведения у другого.

* *Приватный репозиторий* - также корпоративный репозиторий. Этот репозиторий имеет две роли. Первая он выступает в виде прокси, сохраняющего все зависимости, при обращении к центральному репозиторию. Это важно если какая либо зависимость удалиться из центрального репозитория всегда можно гарантировать повторяемую сборку. Вторая роль заключается в публикации приватных зависимостей, которые не должны быть доступны всему миру. Этот репозиторий обеспечивает повторяемую сборку у всех разработчиков внутри корпоративной сети. Обычно в качестве приватного репозитория используется Sonatype Nexus либо JFrog Artifactory.

* *Центральный репозиторий* - репозиторий доступный глобально. По умолчанию Maven Central. Но может быть и другой. Здесь храниться огромной количество зависимостей. Также сюда могут помещаться ваши зависимости, если необходимо чтобы они стали публично доступными.

Собирая проект Maven помещает все зависимости в папку target. Изначально поиск зависимостей производится в локальном репозиторий. В том случае если зависимость не находится производится поиск в приватном, а затем и в центральном репозитории. Если зависимость не находится то процесс сборки упадет. В том случае если зависимость найдена в центральном репозитории, она также помещается в приватный и локальный, чтобы при следующих сборках ее можно было забрать оттуда.

Если зависимость уже есть в локальном репозитории то Maven сразу помещает ее в target и прекращает поиск. Это актуально для всех зависимостей кроме SNAPSHOT.

### Версии. SNAPSHOT

Это версии, которые имеют окончание в название SNAPSHOT. Это такая стадия разработки продукта, когда он постоянно модифицируется но версия не меняется. Указывая версию SNAPSHOT вы даете указание Maven все время проверять что код актуален, т.е. при каждой сборке Maven будет проверять является ли ваша версия последней либо есть уже более новая в приватном/центральном репозитории. И если есть новая тогда будет забирать ее.Для остальных версии действует правило что будучи один раз опубликованым код уже не измениться.

### Профили сборки
Для того что модифицировать поведение Maven для разных сценариев существую профили сборки. Разные профили необходимы и для того чтобы можно было собирать проект в разных окружения: development, build. Также можно более гибко управлять процессом сборки включая, отключая указанные профили. Для указания [профиля](http://maven.apache.org/guides/introduction/introduction-to-profiles.html) сборки необходимо добавить инструкции в раздел **profiles** в **pom.xml**.

Примерный сценарий как происходит CI/CD может выглядеть следующим образом

* Разработка
 1. При разработке проект собирается локально. При этом зависимости забираются из центрального репозитория помещаются в приватный, а также в локальный на машину разработчика.
 * Разработчик пишет код, покрывает его юнит тестами.
 * Разработчик публикует свой код в ветку функциональности в приватный VCS репозиторий.
 * После публикации, автоматически происходит сборка ветки функциональности на билд сервере. Он собирает ее, запускает линтеры, юнит тесты и смок тесты. Если сборка происходит удачно это гарантирует что новый код не ломает предыдущую функциональность.
 * В случает если ветка удачно собраласть артефакт может быть опубликован в приватном репозитории. Это делается для того чтобы он стал доступен другим членам командам (например тестированию).
 * После того как необходимая функциональность закончена создается pull request и код готовиться к слиянию в ветку разработки.

* Публикация (CI)

 1. Изменения в ветке разработки также автоматически запускают сборку ветки на билд сервере. Осуществляются те же самые проверки, а также могут проверяться ряд дополнительных (интеграционные тесты и т.п.), которые затратно запускать на ветках функциональностей.
 * Собранный артефакт помечается как SNAPSHOT и публикуется в приватном репозитории.
* Деплой (CD)
 1. Ветка разработки доходит до стадии новой версии. Код вливается в ветку мастер. Т.к. это обновления то сливания должно пройти без конфликтов.
 * Коммит в ветке мастер помечается тегом с версией.
 * Ветка мастер собирается на билд сервере. Это уже не SNAPSHOT версия. После сборке артифакт публикуется в приватный репозиторий, а также может быть опубликован и в центральный.
 * После создания артефакта и тестирования автоматически запускается процесс выкачивания новой версии на работающие сервера и их обновления.

## Источники

1. [Getting started guide](https://maven.apache.org/guides/getting-started/index.html)
2. [Maven: The Complete Reference (pdf)](http://books.sonatype.com/mvnref-book/pdf/mvnref-pdf.pdf)
3. [Apache Maven Cookbook(pdf)](https://www.javacodegeeks.com/wp-content/uploads/2016/09/Apache-Maven-Cookbook.pdf)
